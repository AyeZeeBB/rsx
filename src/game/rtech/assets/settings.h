#pragma once
#include <game/rtech/assets/settings_layout.h>

enum SettingsModType_e : unsigned short
{
	kIntAdd = 0x0,
	kIntMultiply = 0x1,
	kFloatAdd = 0x2,
	kFloatMultiply = 0x3,
	kBool = 0x4,
	kNumber = 0x5,
	kString = 0x6,

	SETTINGS_MOD_COUNT
};

inline const char* const g_settingsModType[SETTINGS_MOD_COUNT] =
{
	"int_add",
	"int_multipy",
	"float_add",
	"float_multipy",
	"bool",
	"number", // Can be int or float, depends on the data type of the field it modifies.
	"string"
};

union SettingsModValue_u
{
	bool boolValue;
	int intValue;
	float floatValue;
	int stringOffset;
};

struct SettingsMod_s
{
	uint16_t nameIndex; // Index into mod names array.
	SettingsModType_e type;
	uint32_t valueOffset;
	SettingsModValue_u value;
};

struct SettingsAssetHeader_v1_t
{
	uint64_t settingsLayoutGuid;

	char* valueData;

	char* name;

	char* stringData;

	uint32_t uniqueID;
	char unk_24[4]; // padding most likely

	char** modNames;

	SettingsMod_s* modValues;

	int valueBufSize;
	int singlePlayerModCount;
	int modNameCount;
	int modValuesCount;
};
static_assert(sizeof(SettingsAssetHeader_v1_t) == 72);

struct SettingsAssetHeader_v2_t
{
	uint64_t settingsLayoutGuid;

	char* valueData;

	char* name;

	char* stringData;

	char unk_1C[8];

	uint32_t uniqueID;
	char unk_24[4];

	char** modNames;

	SettingsMod_s* modValues;

	int valueBufSize;
	int singlePlayerModCount;
	int modNameCount;
	int modValuesCount;
};
static_assert(sizeof(SettingsAssetHeader_v2_t) == 80);

class CPakAsset;

class SettingsAsset
{
public:
	SettingsAsset(SettingsAssetHeader_v1_t* hdr)
		: layoutGuid(hdr->settingsLayoutGuid), layoutAsset(nullptr), valueData(hdr->valueData), name(hdr->name),
		stringData(hdr->stringData), uniqueId(hdr->uniqueID), modNames(hdr->modNames), modValues(hdr->modValues), valueBufSize(hdr->valueBufSize),
		modFlags(hdr->singlePlayerModCount), modNameCount(hdr->modNameCount), modValuesCount(hdr->modValuesCount)
	{};

	SettingsAsset(SettingsAssetHeader_v2_t* hdr)
		: layoutGuid(hdr->settingsLayoutGuid), layoutAsset(nullptr), valueData(hdr->valueData), name(hdr->name),
		stringData(hdr->stringData), uniqueId(hdr->uniqueID), modNames(hdr->modNames), modValues(hdr->modValues), valueBufSize(hdr->valueBufSize),
		modFlags(hdr->singlePlayerModCount), modNameCount(hdr->modNameCount), modValuesCount(hdr->modValuesCount)
	{};

	uint64_t layoutGuid;
	CPakAsset* layoutAsset;

	char* valueData;
	char* name;

	char* stringData;
	uint32_t uniqueId; // "unique ID generated by Bakery" - used as itemflavor GUID

	char** modNames;
	SettingsMod_s* modValues;

	uint32_t valueBufSize;
	uint32_t modFlags;
	uint32_t modNameCount;
	uint32_t modValuesCount;

public:
	void* GetPointerToValue(uint32_t valueOffset) const
	{
		return reinterpret_cast<char*>(valueData) + valueOffset;
	}

	void R_WriteSetFile(std::string& out, const size_t indentLevel, const char* valueData, const SettingsLayoutAsset* layout);
	void R_WriteSetFile(std::string& out, const size_t indentLevel, const char* valueData, const SettingsLayoutAsset* layout, const SettingsField* const field);

	void R_WriteSetFileArray(std::string& out, const size_t indentLevel, const char* valData, const size_t arrayElemCount, const SettingsLayoutAsset& subLayout);

	void R_WriteModNames(std::string& out) const;
	void R_WriteModValues(std::string& out, const SettingsLayoutAsset* const layout) const;
};