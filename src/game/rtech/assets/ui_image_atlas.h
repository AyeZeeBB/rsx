#pragma once
#include <d3d11.h>
#include <game/rtech/cpakfile.h>

struct UIImageAtlasOffset_t
{
	// on negative values (i.e. -0.1), it starts to clip the image inwards while maintaining offsets.
	// More research is needed here but this seems to be what it is. Possibly to clip out garbage
	// or padding pixels generated by bakery when combining sprites?
	float cropInsetLeft;
	float cropInsetTop;

	// endX and endY define where the edge of the image is, with 1.f being the full length of the image and 0.5f being half of the image
	float endAnchorX;
	float endAnchorY;

	// startX and startY define where the top left corner is in proportion to the full image dimensions
	float startAnchorX;
	float startAnchorY;

	// changing these 2 values causes the image to be distorted on each axis
	float scaleRatioX;
	float scaleRatioY;
};

struct UIImageAtlasDimension_t
{
	uint16_t width;
	uint16_t height;
};

struct UIImageAtlasHash_v10_t
{
	uint32_t pathHash;
	uint16_t unk_4;
	uint16_t pathTableOffset;
};

struct UIImageAtlasHash_v11_t
{
	uint32_t pathHash;
	int pathTableOffset;
	int unk_8;
};

struct UIImageAtlasAssetHeader_v10_t
{
	float widthRatio;
	float heightRatio;

	uint16_t width;
	uint16_t height;

	uint16_t textureCount;
	uint16_t unkCount;

	UIImageAtlasOffset_t* textureOffsets;
	UIImageAtlasDimension_t* textureDimensions; // size used for rendering this image

	void* unk; // unkCount data here (32bytes per structure, being eight floats)

	void* textureHashes; // differs per version
	char* textureNames;

	uint64_t atlasGUID;
};

// [rika]: the image's bounds within the atlas texture
struct UIImageAtlasBounds_t
{
	float minX;
	float minY;

	float sizeX;
	float sizeY;
};

struct UIAtlasImage
{
	std::string path;
	uint32_t pathHash;

	// from this image's bounds
	uint16_t width;
	uint16_t height;

	uint16_t posX;
	uint16_t posY;


	// data used to render this image in game
	// from: UIImageAtlasDimension_t
	uint16_t dimensionsWidth;
	uint16_t dimensionsHeight;

	// store these as a ptr to save size
	const UIImageAtlasOffset_t* offsets;
	const UIImageAtlasBounds_t* bounds;
};

class CTexture;
class UIImageAtlasAsset
{
public:
	UIImageAtlasAsset() = default;
	UIImageAtlasAsset(UIImageAtlasAssetHeader_v10_t* hdr) : widthRatio(hdr->widthRatio), heightRatio(hdr->heightRatio), width(hdr->width), height(hdr->height), textureCount(hdr->textureCount), unkCount(hdr->unkCount),
		textureOffsets(hdr->textureOffsets), textureDimensions(hdr->textureDimensions), unk(hdr->unk), textureHashes(hdr->textureHashes), textureNames(hdr->textureNames), atlasGUID(hdr->atlasGUID),
		rawTxtr(nullptr), convertedTxtr(nullptr), format(DXGI_FORMAT_UNKNOWN) {};

	float widthRatio;
	float heightRatio;

	uint16_t width;
	uint16_t height;

	uint16_t textureCount;
	uint16_t unkCount;

	UIImageAtlasOffset_t* textureOffsets;
	UIImageAtlasDimension_t* textureDimensions;

	void* unk; // unkCount data here (32bytes per structure, being eight floats)

	void* textureHashes; // differs per version
	char* textureNames;

	inline const UIImageAtlasHash_v10_t* const pTextureHash_V10(const uint16_t idx) const { return reinterpret_cast<const UIImageAtlasHash_v10_t* const>(textureHashes) + idx; }
	inline const UIImageAtlasHash_v11_t* const pTextureHash_V11(const uint16_t idx) const { return reinterpret_cast<const UIImageAtlasHash_v11_t* const>(textureHashes) + idx; }

	uint64_t atlasGUID;

	//
	std::shared_ptr<CTexture> rawTxtr;
	std::shared_ptr<CTexture> convertedTxtr;
	DXGI_FORMAT format;
	std::vector<UIAtlasImage> imageArray;
};